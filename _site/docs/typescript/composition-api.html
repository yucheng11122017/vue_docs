<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="generator" content="MarkBind 4.0.2">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title></title>
    <link rel="stylesheet" href="../../markbind/css/bootstrap.min.css">
    <link rel="stylesheet" href="../../markbind/fontawesome/css/all.min.css">
    <link rel="stylesheet" href="../../markbind/glyphicons/css/bootstrap-glyphicons.min.css">
    <link rel="stylesheet" href="../../markbind/css/octicons.css">
    <link rel="stylesheet" href="../../markbind/material-icons/material-icons.css">
    <link rel="stylesheet" href="../../markbind/css/codeblock-dark.min.css"><link rel="stylesheet" href="../../markbind/css/markbind.min.css"><script src="../../markbind/js/polyfill.min.js"></script>
    <script src="../../markbind/js/vue.min.js"></script>
    <script src="../../markbind/js/markbind.min.js"></script>
    <script src="composition-api.page-vue-render.js"></script>
    <script src="../../markbind/js/jquery.min.js"></script><link rel="stylesheet" href="/plugins/markbind-plugin-anchors/markbind-plugin-anchors.css"><link rel="stylesheet" href="/plugins/markbind-plugin-tree/markbind-plugin-tree.css">
    
  <link rel="stylesheet" href="/stylesheets/main.css">
</head>
<script>
  const baseUrl = ''
</script>
<body >
<div id="app" data-server-rendered="true"><header sticky=""><div data-v-15113a2f><nav class="navbar navbar-expand-md d-print-none navbar-dark bg-dark" data-v-15113a2f><div class="container-fluid" data-v-15113a2f><div class="navbar-left" data-v-15113a2f></div> <div class="navbar-default" data-v-15113a2f><ul class="navbar-nav me-auto mt-2 mt-lg-0" data-v-15113a2f><li class="nav-link dropdown" data-v-2e98b3f0><a role="button" data-bs-toggle="dropdown" class="dropdown-toggle" data-v-2e98b3f0>Essentials</a> <ul class="dropdown-menu" data-v-2e98b3f0> <li data-v-2e98b3f0><a href="/docs/essentials/application.html" class="dropdown-item" data-v-2e98b3f0>Creating an Application</a></li></ul></li></ul></div> <ul class="navbar-nav navbar-right" data-v-15113a2f><li data-v-15113a2f><form class="navbar-form" data-v-15113a2f><div class="dropdown" style="position:relative;" data-v-2955e59c><input data-bs-toggle="dropdown" type="text" placeholder="Search" autocomplete="off" value="" class="form-control" data-v-2955e59c> <div class="form-control placeholder-div-hidden" data-v-2955e59c>
      Search
    </div> <ul class="dropdown-menu search-dropdown-menu d-none dropdown-menu-end" data-v-2955e59c></ul></div></form></li></ul></div></nav> <div class="lower-navbar-container" style="display:none;" data-v-15113a2f><!----> <!----></div></div></header> <div id="flex-body"><nav id="site-nav" data-v-e8c82f88><div class="site-nav-top" data-v-e8c82f88><div class="fw-bold mb-2" style="font-size:1.25rem;" data-v-e8c82f88>Template</div></div> <div class="nav-component slim-scroll" data-v-e8c82f88><div class="site-nav-root"><ul class="site-nav-list site-nav-list-root" data-v-e8c82f88><li class="site-nav-custom-list-item site-nav-list-item-0" data-v-e8c82f88>Getting Started</li> <li data-v-e8c82f88><div onclick="handleSiteNavClick(this)" class="site-nav-default-list-item site-nav-list-item-0" data-v-e8c82f88>Essentials 

<i onclick="handleSiteNavClick(this.parentNode, false); event.stopPropagation();" class="site-nav-dropdown-btn-icon site-nav-rotate-icon" data-v-e8c82f88><span aria-hidden="true" class="glyphicon glyphicon-menu-down" data-v-e8c82f88></span></i></div><ul class="site-nav-dropdown-container site-nav-dropdown-container-open site-nav-list" data-v-e8c82f88><li data-v-e8c82f88><div onclick="handleSiteNavClick(this)" class="site-nav-default-list-item site-nav-list-item-1" data-v-e8c82f88><a href="/docs/essentials/application.html" data-v-e8c82f88>Creating an Application</a></div></li></ul></li> <li class="site-nav-custom-list-item site-nav-list-item-0" data-v-e8c82f88>Components In-Depth</li> <li class="site-nav-custom-list-item site-nav-list-item-0" data-v-e8c82f88>Reusability</li> <li class="site-nav-custom-list-item site-nav-list-item-0" data-v-e8c82f88>Built-in Components</li> <li class="site-nav-custom-list-item site-nav-list-item-0" data-v-e8c82f88>Scaling Up</li> <li class="site-nav-custom-list-item site-nav-list-item-0" data-v-e8c82f88>Best Practices</li> <li data-v-e8c82f88><div onclick="handleSiteNavClick(this)" class="site-nav-default-list-item site-nav-list-item-0" data-v-e8c82f88>TypeScript 

<i onclick="handleSiteNavClick(this.parentNode, false); event.stopPropagation();" class="site-nav-dropdown-btn-icon site-nav-rotate-icon" data-v-e8c82f88><span aria-hidden="true" class="glyphicon glyphicon-menu-down" data-v-e8c82f88></span></i></div><ul class="site-nav-dropdown-container site-nav-dropdown-container-open site-nav-list" data-v-e8c82f88><li data-v-e8c82f88><div onclick="handleSiteNavClick(this)" class="site-nav-default-list-item site-nav-list-item-1" data-v-e8c82f88><a href="/docs/typescript/overview.html" data-v-e8c82f88>Overview</a></div></li> <li data-v-e8c82f88><div onclick="handleSiteNavClick(this)" class="site-nav-default-list-item site-nav-list-item-1" data-v-e8c82f88><a href="/docs/typescript/composition-api.html" data-v-e8c82f88>TS with Composition API</a></div></li> <li data-v-e8c82f88><div onclick="handleSiteNavClick(this)" class="site-nav-default-list-item site-nav-list-item-1" data-v-e8c82f88><a href="/docs/typescript/options-api.html" data-v-e8c82f88>TS with Options API</a></div></li></ul></li> <!----></ul> <ul class="site-nav-list site-nav-list-root" data-v-e8c82f88><li class="site-nav-custom-list-item site-nav-list-item-0" data-v-e8c82f88>Extra Topics</li> <!----></ul></div></div> <!----></nav> <div id="content-wrapper"><h1 id="typescript-with-composition-api"><span id="typescript-with-composition-api" class="anchor"></span>TypeScript with Composition API<a href="#typescript-with-composition-api" onclick="event.stopPropagation()" class="fa fa-anchor"></a></h1> <blockquote><p>This page assumes you've already read the overview on <a href="/docs/typescript/overview">Using Vue with TypeScript</a>.</p></blockquote> <hr> <h2 id="typing-component-props"><span id="typing-component-props" class="anchor"></span>Typing Component Props<a href="#typing-component-props" onclick="event.stopPropagation()" class="fa fa-anchor"></a></h2> <h3 id="using-script-setup"><span id="using-script-setup" class="anchor"></span>Using <code class="hljs inline no-lang">&lt;script setup&gt;</code><a href="#using-script-setup" onclick="event.stopPropagation()" class="fa fa-anchor"></a></h3> <p>When using <code class="hljs inline no-lang">&lt;script setup&gt;</code>, the <code class="hljs inline no-lang">defineProps()</code> macro supports inferring the props types based on its argument:</p> <pre><code class="hljs"><span>&lt;script setup lang=&quot;ts&quot;&gt;
</span><span>const props = defineProps({
</span><span>  foo: { type: String, required: true },
</span><span>  bar: Number
</span><span>})
</span><span>
</span><span>props.foo // string
</span><span>props.bar // number | undefined
</span><span>&lt;/script&gt;
</span></code></pre><p>This is called &quot;runtime declaration&quot;, because the argument passed to <code class="hljs inline no-lang">defineProps()</code> will be used as the runtime <code class="hljs inline no-lang">props</code> option.</p> <p>However, it is usually more straightforward to define props with pure types via a generic type argument:</p> <pre><code class="hljs"><span>&lt;script setup lang=&quot;ts&quot;&gt;
</span><span>const props = defineProps&lt;{
</span><span>  foo: string
</span><span>  bar?: number
</span><span>}&gt;()
</span><span>&lt;/script&gt;
</span></code></pre><p>This is called &quot;type-based declaration&quot;. The compiler will try to do its best to infer the equivalent runtime options based on the type argument. In this case, our second example compiles into the exact same runtime options as the first example.</p> <p>You can use either type-based declaration OR runtime declaration, but you cannot use both at the same time.</p> <p>We can also move the props types into a separate interface:</p> <pre><code class="hljs"><span>&lt;script setup lang=&quot;ts&quot;&gt;
</span><span>interface Props {
</span><span>  foo: string
</span><span>  bar?: number
</span><span>}
</span><span>
</span><span>const props = defineProps&lt;Props&gt;()
</span><span>&lt;/script&gt;
</span></code></pre><h4 id="syntax-limitations"><span id="syntax-limitations" class="anchor"></span>Syntax Limitations<a href="#syntax-limitations" onclick="event.stopPropagation()" class="fa fa-anchor"></a></h4> <p>In order to generate the correct runtime code, the generic argument for <code class="hljs inline no-lang">defineProps()</code> must be one of the following:</p> <ul><li><p>An object literal type:</p> <pre><code class="hljs ts"><span>defineProps&lt;{ <span class="hljs-comment">/*... */</span> }&gt;()
</span></code></pre></li> <li><p>A reference to an interface or object literal type <strong>in the same file</strong>:</p> <pre><code class="hljs ts"><span><span class="hljs-keyword">interface</span> Props {<span class="hljs-comment">/* ... */</span>}
</span><span>
</span><span>defineProps&lt;Props&gt;()
</span></code></pre></li></ul> <p>The interface or object literal type can contain references to types imported from other files, however, the generic argument itself passed to <code class="hljs inline no-lang">defineProps</code> <strong>cannot</strong> be an imported type:</p> <pre><code class="hljs ts"><span><span class="hljs-keyword">import</span> { Props } <span class="hljs-keyword">from</span> <span class="hljs-string">'./other-file'</span>
</span><span>
</span><span><span class="hljs-comment">// NOT supported</span>
</span><span>defineProps&lt;Props&gt;()
</span></code></pre><p>This is because Vue components are compiled in isolation and the compiler currently does not crawl imported files in order to analyze the source type. This limitation could be removed in a future release.</p> <h3 id="props-default-values"><span id="props-default-values" class="anchor"></span>Props Default Values<a href="#props-default-values" onclick="event.stopPropagation()" class="fa fa-anchor"></a></h3> <p>When using type-based declaration, we lose the ability to declare default values for the props. This can be resolved by the <code class="hljs inline no-lang">withDefaults</code> compiler macro:</p> <pre><code class="hljs ts"><span><span class="hljs-keyword">export</span> <span class="hljs-keyword">interface</span> Props {
</span><span>  msg?: <span class="hljs-built_in">string</span>
</span><span>  labels?: <span class="hljs-built_in">string</span>[]
</span><span>}
</span><span>
</span><span><span class="hljs-keyword">const</span> props = withDefaults(defineProps&lt;Props&gt;(), {
</span><span>  <span class="hljs-attr">msg</span>: <span class="hljs-string">'hello'</span>,
</span><span>  <span class="hljs-attr">labels</span>: <span class="hljs-function">() =&gt;</span> [<span class="hljs-string">'one'</span>, <span class="hljs-string">'two'</span>]
</span><span>})
</span></code></pre><p>This will be compiled to equivalent runtime props <code class="hljs inline no-lang">default</code> options. In addition, the <code class="hljs inline no-lang">withDefaults</code> helper provides type checks for the default values, and ensures the returned <code class="hljs inline no-lang">props</code> type has the optional flags removed for properties that do have default values declared.</p> <p>Alternatively, you can use the currently experimental <a href="/guide/extras/reactivity-transform.html">Reactivity Transform</a>:</p> <pre><code class="hljs"><span>&lt;script setup lang=&quot;ts&quot;&gt;
</span><span>interface Props {
</span><span>  name: string
</span><span>  count?: number
</span><span>}
</span><span>
</span><span>// reactive destructure for defineProps()
</span><span>// default value is compiled to equivalent runtime option
</span><span>const { name, count = 100 } = defineProps&lt;Props&gt;()
</span><span>&lt;/script&gt;
</span></code></pre><p>This behavior currently requires <a href="/guide/extras/reactivity-transform.html#explicit-opt-in">explicit opt-in</a>.</p> <h3 id="without-script-setup"><span id="without-script-setup" class="anchor"></span>Without <code class="hljs inline no-lang">&lt;script setup&gt;</code><a href="#without-script-setup" onclick="event.stopPropagation()" class="fa fa-anchor"></a></h3> <p>If not using <code class="hljs inline no-lang">&lt;script setup&gt;</code>, it is necessary to use <code class="hljs inline no-lang">defineComponent()</code> to enable props type inference. The type of the props object passed to <code class="hljs inline no-lang">setup()</code> is inferred from the <code class="hljs inline no-lang">props</code> option.</p> <pre><code class="hljs ts"><span><span class="hljs-keyword">import</span> { defineComponent } <span class="hljs-keyword">from</span> <span class="hljs-string">'vue'</span>
</span><span>
</span><span><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> defineComponent({
</span><span>  <span class="hljs-attr">props</span>: {
</span><span>    <span class="hljs-attr">message</span>: <span class="hljs-built_in">String</span>
</span><span>  },
</span><span>  <span class="hljs-function"><span class="hljs-title">setup</span>(<span class="hljs-params">props</span>)</span> {
</span><span>    props.message <span class="hljs-comment">// &lt;-- type: string</span>
</span><span>  }
</span><span>})
</span></code></pre><h3 id="complex-prop-types"><span id="complex-prop-types" class="anchor"></span>Complex prop types<a href="#complex-prop-types" onclick="event.stopPropagation()" class="fa fa-anchor"></a></h3> <p>With type-based declaration, a prop can use a complex type much like any other type:</p> <pre><code class="hljs"><span>&lt;script setup lang=&quot;ts&quot;&gt;
</span><span>interface Book {
</span><span>  title: string
</span><span>  author: string
</span><span>  year: number
</span><span>}
</span><span>
</span><span>const props = defineProps&lt;{
</span><span>  book: Book
</span><span>}&gt;()
</span><span>&lt;/script&gt;
</span></code></pre><p>For runtime declaration, we can use the <code class="hljs inline no-lang">PropType</code> utility type:</p> <pre><code class="hljs ts"><span><span class="hljs-keyword">import</span> <span class="hljs-keyword">type</span> { PropType } <span class="hljs-keyword">from</span> <span class="hljs-string">'vue'</span>
</span><span>
</span><span><span class="hljs-keyword">const</span> props = defineProps({
</span><span>  <span class="hljs-attr">book</span>: <span class="hljs-built_in">Object</span> <span class="hljs-keyword">as</span> PropType&lt;Book&gt;
</span><span>})
</span></code></pre><p>This works in much the same way if we're specifying the <code class="hljs inline no-lang">props</code> option directly:</p> <pre><code class="hljs ts"><span><span class="hljs-keyword">import</span> { defineComponent } <span class="hljs-keyword">from</span> <span class="hljs-string">'vue'</span>
</span><span><span class="hljs-keyword">import</span> <span class="hljs-keyword">type</span> { PropType } <span class="hljs-keyword">from</span> <span class="hljs-string">'vue'</span>
</span><span>
</span><span><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> defineComponent({
</span><span>  <span class="hljs-attr">props</span>: {
</span><span>    <span class="hljs-attr">book</span>: <span class="hljs-built_in">Object</span> <span class="hljs-keyword">as</span> PropType&lt;Book&gt;
</span><span>  }
</span><span>})
</span></code></pre><p>The <code class="hljs inline no-lang">props</code> option is more commonly used with the Options API, so you'll find more detailed examples in the guide to <a href="/guide/typescript/options-api.html#typing-component-props">TypeScript with Options API</a>. The techniques shown in those examples also apply to runtime declarations using <code class="hljs inline no-lang">defineProps()</code>.</p> <hr> <h2 id="typing-component-emits"><span id="typing-component-emits" class="anchor"></span>Typing Component Emits<a href="#typing-component-emits" onclick="event.stopPropagation()" class="fa fa-anchor"></a></h2> <p>In <code class="hljs inline no-lang">&lt;script setup&gt;</code>, the <code class="hljs inline no-lang">emit</code> function can also be typed using either runtime declaration OR type declaration:</p> <pre><code class="hljs"><span>&lt;script setup lang=&quot;ts&quot;&gt;
</span><span>// runtime
</span><span>const emit = defineEmits(['change', 'update'])
</span><span>
</span><span>// type-based
</span><span>const emit = defineEmits&lt;{
</span><span>  (e: 'change', id: number): void
</span><span>  (e: 'update', value: string): void
</span><span>}&gt;()
</span><span>&lt;/script&gt;
</span></code></pre><p>The type argument should be a type literal with <a href="https://www.typescriptlang.org/docs/handbook/2/functions.html#call-signatures">Call Signatures</a>. The type literal will be used as the type of the returned <code class="hljs inline no-lang">emit</code> function. As we can see, the type declaration gives us much finer-grained control over the type constraints of emitted events.</p> <p>When not using <code class="hljs inline no-lang">&lt;script setup&gt;</code>, <code class="hljs inline no-lang">defineComponent()</code> is able to infer the allowed events for the <code class="hljs inline no-lang">emit</code> function exposed on the setup context:</p> <pre><code class="hljs ts"><span><span class="hljs-keyword">import</span> { defineComponent } <span class="hljs-keyword">from</span> <span class="hljs-string">'vue'</span>
</span><span>
</span><span><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> defineComponent({
</span><span>  <span class="hljs-attr">emits</span>: [<span class="hljs-string">'change'</span>],
</span><span>  <span class="hljs-function"><span class="hljs-title">setup</span>(<span class="hljs-params">props, { emit }</span>)</span> {
</span><span>    emit(<span class="hljs-string">'change'</span>) <span class="hljs-comment">// &lt;-- type check / auto-completion</span>
</span><span>  }
</span><span>})
</span></code></pre><hr> <h2 id="typing-ref"><span id="typing-ref" class="anchor"></span>Typing <code class="hljs inline no-lang">ref()</code><a href="#typing-ref" onclick="event.stopPropagation()" class="fa fa-anchor"></a></h2> <p>Refs infer the type from the initial value:</p> <pre><code class="hljs ts"><span><span class="hljs-keyword">import</span> { ref } <span class="hljs-keyword">from</span> <span class="hljs-string">'vue'</span>
</span><span>
</span><span><span class="hljs-comment">// inferred type: Ref&lt;number&gt;</span>
</span><span><span class="hljs-keyword">const</span> year = ref(<span class="hljs-number">2020</span>)
</span><span>
</span><span><span class="hljs-comment">// =&gt; TS Error: Type 'string' is not assignable to type 'number'.</span>
</span><span>year.value = <span class="hljs-string">'2020'</span>
</span></code></pre><p>Sometimes we may need to specify complex types for a ref's inner value. We can do that by using the <code class="hljs inline no-lang">Ref</code> type:</p> <pre><code class="hljs ts"><span><span class="hljs-keyword">import</span> { ref } <span class="hljs-keyword">from</span> <span class="hljs-string">'vue'</span>
</span><span><span class="hljs-keyword">import</span> <span class="hljs-keyword">type</span> { Ref } <span class="hljs-keyword">from</span> <span class="hljs-string">'vue'</span>
</span><span>
</span><span><span class="hljs-keyword">const</span> year: Ref&lt;<span class="hljs-built_in">string</span> | <span class="hljs-built_in">number</span>&gt; = ref(<span class="hljs-string">'2020'</span>)
</span><span>
</span><span>year.value = <span class="hljs-number">2020</span> <span class="hljs-comment">// ok!</span>
</span></code></pre><p>Or, by passing a generic argument when calling <code class="hljs inline no-lang">ref()</code> to override the default inference:</p> <pre><code class="hljs ts"><span><span class="hljs-comment">// resulting type: Ref&lt;string | number&gt;</span>
</span><span><span class="hljs-keyword">const</span> year = ref&lt;<span class="hljs-built_in">string</span> | <span class="hljs-built_in">number</span>&gt;(<span class="hljs-string">'2020'</span>)
</span><span>
</span><span>year.value = <span class="hljs-number">2020</span> <span class="hljs-comment">// ok!</span>
</span></code></pre><p>If you specify a generic type argument but omit the initial value, the resulting type will be a union type that includes <code class="hljs inline no-lang">undefined</code>:</p> <pre><code class="hljs ts"><span><span class="hljs-comment">// inferred type: Ref&lt;number | undefined&gt;</span>
</span><span><span class="hljs-keyword">const</span> n = ref&lt;<span class="hljs-built_in">number</span>&gt;()
</span></code></pre><hr> <h2 id="typing-reactive"><span id="typing-reactive" class="anchor"></span>Typing <code class="hljs inline no-lang">reactive()</code><a href="#typing-reactive" onclick="event.stopPropagation()" class="fa fa-anchor"></a></h2> <p><code class="hljs inline no-lang">reactive()</code> also implicitly infers the type from its argument:</p> <pre><code class="hljs ts"><span><span class="hljs-keyword">import</span> { reactive } <span class="hljs-keyword">from</span> <span class="hljs-string">'vue'</span>
</span><span>
</span><span><span class="hljs-comment">// inferred type: { title: string }</span>
</span><span><span class="hljs-keyword">const</span> book = reactive({ <span class="hljs-attr">title</span>: <span class="hljs-string">'Vue 3 Guide'</span> })
</span></code></pre><p>To explicitly type a <code class="hljs inline no-lang">reactive</code> property, we can use interfaces:</p> <pre><code class="hljs ts"><span><span class="hljs-keyword">import</span> { reactive } <span class="hljs-keyword">from</span> <span class="hljs-string">'vue'</span>
</span><span>
</span><span><span class="hljs-keyword">interface</span> Book {
</span><span>  <span class="hljs-attr">title</span>: <span class="hljs-built_in">string</span>
</span><span>  year?: <span class="hljs-built_in">number</span>
</span><span>}
</span><span>
</span><span><span class="hljs-keyword">const</span> book: Book = reactive({ <span class="hljs-attr">title</span>: <span class="hljs-string">'Vue 3 Guide'</span> })
</span></code></pre><div class="alert box-container alert-info" data-v-7d17494f><!----> <div class="header-and-body" data-v-7d17494f><!----> <div class="box-body-wrapper" data-v-7d17494f><div class="icon-wrapper" data-v-7d17494f><i class="fas fa-info" data-v-7d17494f></i></div> <!----> <div class="contents" data-v-7d17494f>
It's not recommended to use the generic argument of `reactive()` because the returned type, which handles nested ref unwrapping, is different from the generic argument type.
</div> <!----></div></div></div> <hr> <h2 id="typing-computed"><span id="typing-computed" class="anchor"></span>Typing <code class="hljs inline no-lang">computed()</code><a href="#typing-computed" onclick="event.stopPropagation()" class="fa fa-anchor"></a></h2> <p><code class="hljs inline no-lang">computed()</code> infers its type based on the getter's return value:</p> <pre><code class="hljs ts"><span><span class="hljs-keyword">import</span> { ref, computed } <span class="hljs-keyword">from</span> <span class="hljs-string">'vue'</span>
</span><span>
</span><span><span class="hljs-keyword">const</span> count = ref(<span class="hljs-number">0</span>)
</span><span>
</span><span><span class="hljs-comment">// inferred type: ComputedRef&lt;number&gt;</span>
</span><span><span class="hljs-keyword">const</span> double = computed(<span class="hljs-function">() =&gt;</span> count.value * <span class="hljs-number">2</span>)
</span><span>
</span><span><span class="hljs-comment">// =&gt; TS Error: Property 'split' does not exist on type 'number'</span>
</span><span><span class="hljs-keyword">const</span> result = double.value.split(<span class="hljs-string">''</span>)
</span></code></pre><p>You can also specify an explicit type via a generic argument:</p> <pre><code class="hljs ts"><span><span class="hljs-keyword">const</span> double = computed&lt;<span class="hljs-built_in">number</span>&gt;(<span class="hljs-function">() =&gt;</span> {
</span><span>  <span class="hljs-comment">// type error if this doesn't return a number</span>
</span><span>})
</span></code></pre><hr> <h2 id="typing-event-handlers"><span id="typing-event-handlers" class="anchor"></span>Typing Event Handlers<a href="#typing-event-handlers" onclick="event.stopPropagation()" class="fa fa-anchor"></a></h2> <p>When dealing with native DOM events, it might be useful to type the argument we pass to the handler correctly. Let's take a look at this example:</p> <pre><code class="hljs"><span>&lt;script setup lang=&quot;ts&quot;&gt;
</span><span>function handleChange(event) {
</span><span>  // `event` implicitly has `any` type
</span><span>  console.log(event.target.value)
</span><span>}
</span><span>&lt;/script&gt;
</span><span>
</span><span>&lt;template&gt;
</span><span>  &lt;input type=&quot;text&quot; @change=&quot;handleChange&quot; /&gt;
</span><span>&lt;/template&gt;
</span></code></pre><p>Without type annotation, the <code class="hljs inline no-lang">event</code> argument will implicitly have a type of <code class="hljs inline no-lang">any</code>. This will also result in a TS error if <code class="hljs inline no-lang">&quot;strict&quot;: true</code> or <code class="hljs inline no-lang">&quot;noImplicitAny&quot;: true</code> are used in <code class="hljs inline no-lang">tsconfig.json</code>. It is therefore recommended to explicitly annotate the argument of event handlers. In addition, you may need to explicitly cast properties on <code class="hljs inline no-lang">event</code>:</p> <pre><code class="hljs ts"><span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">handleChange</span>(<span class="hljs-params">event: Event</span>) </span>{
</span><span>  <span class="hljs-built_in">console</span>.log((event.target <span class="hljs-keyword">as</span> HTMLInputElement).value)
</span><span>}
</span></code></pre><hr> <h2 id="typing-provide-inject"><span id="typing-provide-inject" class="anchor"></span>Typing Provide / Inject<a href="#typing-provide-inject" onclick="event.stopPropagation()" class="fa fa-anchor"></a></h2> <p>Provide and inject are usually performed in separate components. To properly type injected values, Vue provides an <code class="hljs inline no-lang">InjectionKey</code> interface, which is a generic type that extends <code class="hljs inline no-lang">Symbol</code>. It can be used to sync the type of the injected value between the provider and the consumer:</p> <pre><code class="hljs ts"><span><span class="hljs-keyword">import</span> { provide, inject } <span class="hljs-keyword">from</span> <span class="hljs-string">'vue'</span>
</span><span><span class="hljs-keyword">import</span> <span class="hljs-keyword">type</span> { InjectionKey } <span class="hljs-keyword">from</span> <span class="hljs-string">'vue'</span>
</span><span>
</span><span><span class="hljs-keyword">const</span> key = <span class="hljs-built_in">Symbol</span>() <span class="hljs-keyword">as</span> InjectionKey&lt;<span class="hljs-built_in">string</span>&gt;
</span><span>
</span><span>provide(key, <span class="hljs-string">'foo'</span>) <span class="hljs-comment">// providing non-string value will result in error</span>
</span><span>
</span><span><span class="hljs-keyword">const</span> foo = inject(key) <span class="hljs-comment">// type of foo: string | undefined</span>
</span></code></pre><p>It's recommended to place the injection key in a separate file so that it can be imported in multiple components.</p> <p>When using string injection keys, the type of the injected value will be <code class="hljs inline no-lang">unknown</code>, and needs to be explicitly declared via a generic type argument:</p> <pre><code class="hljs ts"><span><span class="hljs-keyword">const</span> foo = inject&lt;<span class="hljs-built_in">string</span>&gt;(<span class="hljs-string">'foo'</span>) <span class="hljs-comment">// type: string | undefined</span>
</span></code></pre><p>Notice the injected value can still be <code class="hljs inline no-lang">undefined</code>, because there is no guarantee that a provider will provide this value at runtime.</p> <p>The <code class="hljs inline no-lang">undefined</code> type can be removed by providing a default value:</p> <pre><code class="hljs ts"><span><span class="hljs-keyword">const</span> foo = inject&lt;<span class="hljs-built_in">string</span>&gt;(<span class="hljs-string">'foo'</span>, <span class="hljs-string">'bar'</span>) <span class="hljs-comment">// type: string</span>
</span></code></pre><p>If you are sure that the value is always provided, you can also force cast the value:</p> <pre><code class="hljs ts"><span><span class="hljs-keyword">const</span> foo = inject(<span class="hljs-string">'foo'</span>) <span class="hljs-keyword">as</span> <span class="hljs-built_in">string</span>
</span></code></pre><hr> <h2 id="typing-template-refs"><span id="typing-template-refs" class="anchor"></span>Typing Template Refs<a href="#typing-template-refs" onclick="event.stopPropagation()" class="fa fa-anchor"></a></h2> <p>Template refs should be created with an explicit generic type argument and an initial value of <code class="hljs inline no-lang">null</code>:</p> <pre><code class="hljs"><span>&lt;script setup lang=&quot;ts&quot;&gt;
</span><span>import { ref, onMounted } from 'vue'
</span><span>
</span><span>const el = ref&lt;HTMLInputElement | null&gt;(null)
</span><span>
</span><span>onMounted(() =&gt; {
</span><span>  el.value?.focus()
</span><span>})
</span><span>&lt;/script&gt;
</span><span>
</span><span>&lt;template&gt;
</span><span>  &lt;input ref=&quot;el&quot; /&gt;
</span><span>&lt;/template&gt;
</span></code></pre><p>Note that for strict type safety, it is necessary to use optional chaining or type guards when accessing <code class="hljs inline no-lang">el.value</code>. This is because the initial ref value is <code class="hljs inline no-lang">null</code> until the component is mounted, and it can also be set to <code class="hljs inline no-lang">null</code> if the referenced element is unmounted by <code class="hljs inline no-lang">v-if</code>.</p> <hr> <h2 id="typing-component-template-refs"><span id="typing-component-template-refs" class="anchor"></span>Typing Component Template Refs<a href="#typing-component-template-refs" onclick="event.stopPropagation()" class="fa fa-anchor"></a></h2> <p>Sometimes you might need to annotate a template ref for a child component in order to call its public method. For example, we have a <code class="hljs inline no-lang">MyModal</code> child component with a method that opens the modal:</p> <pre><code class="hljs"><span>&lt;!-- MyModal.vue --&gt;
</span><span>&lt;script setup lang=&quot;ts&quot;&gt;
</span><span>import { ref } from 'vue'
</span><span>
</span><span>const isContentShown = ref(false)
</span><span>const open = () =&gt; (isContentShown.value = true)
</span><span>
</span><span>defineExpose({
</span><span>  open
</span><span>})
</span><span>&lt;/script&gt;
</span></code></pre><p>In order to get the instance type of <code class="hljs inline no-lang">MyModal</code>, we need to first get its type via <code class="hljs inline no-lang">typeof</code>, then use TypeScript's built-in <code class="hljs inline no-lang">InstanceType</code> utility to extract its instance type:</p> <pre><code 5="" class="hljs"><span>&lt;!-- App.vue --&gt;
</span><span>&lt;script setup lang=&quot;ts&quot;&gt;
</span><span>import MyModal from './MyModal.vue'
</span><span>
</span><span>const modal = ref&lt;InstanceType&lt;typeof MyModal&gt; | null&gt;(null)
</span><span>
</span><span>const openModal = () =&gt; {
</span><span>  modal.value?.open()
</span><span>}
</span><span>&lt;/script&gt;
</span></code></pre><p>Note if you want to use this technique in TypeScript files instead of Vue SFCs, you need to enable Volar's <a href="/docs/typescript/overview.html#volar-takeover-mode">Takeover Mode</a>.</p> <i id="scroll-top-button" onclick="handleScrollTop()" aria-hidden="true" class="fa fa-arrow-circle-up fa-lg d-print-none"></i></div> <nav id="page-nav" data-v-e8c82f88><div class="nav-component slim-scroll" data-v-e8c82f88></div> <!----></nav></div> <footer><div class="text-center"><small>[Generated by <a href="https://markbind.org/">MarkBind 4.0.2</a>]</small></div></footer></div>
</body><script src="../../markbind/js/bootstrap-utility.min.js"></script>
<script>
  MarkBind.setupWithSearch()
</script>
</html>
